// Make sure this file is not included twice
#ifndef PROCEDURAL_MESH_DRAWER_INCLUDED
#define PROCEDURAL_MESH_DRAWER_INCLUDED

// Include helper functions from URP
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
#include "ProceduralMeshGraphicsHelpers.hlsl"

// This describes a vertex on the generated mesh
struct GlobalVertex
{
	float3 positionWS; // position in world space
	float2 uv; // UV
	float4 color;// Vertex Color
};

// We have to insert three draw vertices at once so the triangle stays connected
// in the graphics shader. This structure does that
struct DrawTriangle
{
	float3 normalWS; // normal in world space. All points share this normal
	//GlobalVertex vertices[3];
	GlobalVertex vertex0;
	GlobalVertex vertex1;
	GlobalVertex vertex2;
};
// The buffer to draw from
StructuredBuffer<DrawTriangle> _DrawTriangles;

// This structure is generated by the vertex function and passed to the geometry function
struct VertexOutput
{
	float3 positionWS : TEXCOORD0; // Position in world space
	float3 normalWS : TEXCOORD1; // Normal vector in world space
	float2 uv : TEXCOORD2; // UVs
	float4 positionCS : SV_POSITION; // Position in clip space
	float4 color : COLOR0;
};

// The _MainTex property. The sampler and scale/offset vector is also created
TEXTURE2D(_MainTex); SAMPLER(sampler_MainTex);
float4 _MainTex_ST;

float4 GetColorFromPos(float3 position)
{
	float4 color = float4(1, 1, 1, 1);
	float3 center = float3(128, 128, 128);
	float dist = distance(center, position);
	
	float t = 1;
	
	if (dist < 90)
	{
		t = 1;
	}
	else
	{
		t = 1 - (dist - 90) / 15.0f;
	}
		
	if (dist < 50)
	{
		color = float4(3 / 4.0f, lerp(1, 0, dist / 50), lerp(1, 0, dist / 50), 1);
	}
	else
	{
		color = float4(0, 1 / 2.0f, lerp(0, 1, t), 1);
	}
	
	return color;
}

float4 AverageColor(DrawTriangle tri)
{
	float r = 0, g = 0, b = 0, a = 0;
	
	r += tri.vertex0.color.r;
	r += tri.vertex1.color.r;
	r += tri.vertex2.color.r;
	
	g += tri.vertex0.color.g;
	g += tri.vertex1.color.g;
	g += tri.vertex2.color.g;
	
	b += tri.vertex0.color.b;
	b += tri.vertex1.color.b;
	b += tri.vertex2.color.b;
	
	a += tri.vertex0.color.a;
	a += tri.vertex1.color.a;
	a += tri.vertex2.color.a;
	
	return float4(r, g, b, a) / 4.0f;
}

float4 AverageColor(float4 color0, float4 color1, float4 color2)
{
	float r = 0, g = 0, b = 0, a = 0;
	
	r += color0.r;
	r += color1.r;
	r += color2.r;
	
	g += color0.g;
	g += color1.g;
	g += color2.g;
	
	b += color0.b;
	b += color1.b;
	b += color2.b;
	
	a += color0.a;
	a += color1.a;
	a += color2.a;
	
	return float4(r, g, b, a) / 4.0f;
}

// Vertex functions

// The SV_VertexID semantic is an index we can use to get a vertex to work on
// The max value of this is the first argument in the indirect args buffer
// The system will create triangles out of each three consecutive vertices
VertexOutput Vertex(uint vertexID : SV_VertexID)
{
    // Initialize the output struct
	VertexOutput output = (VertexOutput) 0;

    // Get the vertex from the buffer
    // Since the buffer is structured in triangles, we need to divide the vertexID by three
    // to get the triangle, and then modulo by 3 to get the vertex on the triangle
	DrawTriangle tri = _DrawTriangles[vertexID / 3];
	//DrawVertex input = tri.vertices[vertexID % 3];
	
	GlobalVertex input;	
	
	if (vertexID % 3 == 0)
	{
		input = tri.vertex0;		
	}
	else if (vertexID % 3 == 1)
	{
		input = tri.vertex1;
	}
	else
	{
		input = tri.vertex2;		
	}
	
	float4 averageColor = AverageColor(GetColorFromPos(tri.vertex0.positionWS), GetColorFromPos(tri.vertex0.positionWS), GetColorFromPos(tri.vertex0.positionWS));

	output.color = averageColor;
	//output.color = GetColorFromPos(input.positionWS);
	//output.color = input.color;
	output.positionWS = input.positionWS;
	output.normalWS = tri.normalWS;
	output.uv = TRANSFORM_TEX(input.uv, _MainTex);
    // Apply shadow caster logic to the CS position
	output.positionCS = CalculatePositionCSWithShadowCasterLogic(input.positionWS, tri.normalWS);

	return output;
}

// Fragment functions

// The SV_Target semantic tells the compiler that this function outputs the pixel color
float4 Fragment(VertexOutput input) : SV_Target
{

#ifdef SHADOW_CASTER_PASS
    // If in the shadow caster pass, we can just return now
    // It's enough to signal that should will cast a shadow
    return 0;
#else
    // Initialize some information for the lighting function
	InputData lightingInput = (InputData) 0;
	lightingInput.positionWS = input.positionWS;
	lightingInput.normalWS = input.normalWS; // No need to renormalize, since triangles all share normals
	lightingInput.viewDirectionWS = GetViewDirectionFromPosition(input.positionWS);
	lightingInput.shadowCoord = CalculateShadowCoord(input.positionWS, input.positionCS);

    // Read the main texture
	float3 albedo = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, input.uv).rgb * input.color;

    // Call URP's simple lighting function
    // The arguments are lightingInput, albedo color, specular color, smoothness, emission color, and alpha

	return UniversalFragmentBlinnPhong(lightingInput, albedo, 1, 0, 0, 1);
#endif
}

#endif